import { DEFAULT_COL_GAP } from '../lib/canvas-layout';
import { STORAGE_KEYS } from '../lib/storage-keys';
import { EDGE_TYPES, EDGE_STATUS } from '../constants/canvas';

/** Safely read and parse a localStorage JSON entry. Returns null on any failure. */
function readLocalStorageJson(key: string): unknown {
  const raw = localStorage.getItem(key);
  if (!raw) return null;
  try {
    return JSON.parse(raw);
  } catch (e) {
    console.warn(`[canvas-migrations] Failed to parse localStorage key "${key}"`, e);
    return null;
  }
}

const FRESH_STATE = {
  nodes: [],
  edges: [],
  viewport: { x: 0, y: 0, zoom: 0.85 },
  showMiniMap: true,
  showGrid: true,
  colGap: DEFAULT_COL_GAP,
  autoLayout: true,
};

// ── Per-version migration functions ──────────────────────────────────

/** v2 → v3: fix stale 'incubator' nodes */
function migrateV2ToV3(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];
  return {
    ...s,
    nodes: nodes.map((n) => ({
      ...n,
      type: n.type === 'incubator' ? 'designer' : n.type,
      id: n.id === 'incubator-node' ? 'generator-node' : n.id,
    })),
    edges: edges.map((e) => ({
      ...e,
      source: e.source === 'incubator-node' ? 'generator-node' : e.source,
      target: e.target === 'incubator-node' ? 'generator-node' : e.target,
      id: typeof e.id === 'string' ? e.id.replace('incubator', 'designer') : e.id,
    })),
  };
}

/** v5 → v6: rename 'generator' node type to 'designer' */
function migrateV5ToV6(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];
  return {
    ...s,
    nodes: nodes.map((n) => ({
      ...n,
      type: n.type === 'generator' ? 'designer' : n.type,
    })),
    edges: edges.map((e) => ({
      ...e,
      id: typeof e.id === 'string' ? e.id.replace('generator', 'designer') : e.id,
    })),
  };
}

/** v6 → v7: add variantStrategyId to variant nodes from generation store */
function migrateV6ToV7(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];

  const genParsed = readLocalStorageJson(STORAGE_KEYS.GENERATION) as Record<string, unknown> | null;
  const genResults: Array<Record<string, unknown>> =
    (genParsed?.state as Record<string, unknown> | undefined)?.results as Array<Record<string, unknown>> ?? [];

  const resultById = new Map<string, string>();
  for (const r of genResults) {
    if (r.id && r.variantStrategyId) {
      resultById.set(r.id as string, r.variantStrategyId as string);
    }
  }

  return {
    ...s,
    nodes: nodes.map((n) => {
      if (n.type === 'variant' && n.data) {
        const data = n.data as Record<string, unknown>;
        if (!data.variantStrategyId && data.refId) {
          const vsId = resultById.get(data.refId as string);
          if (vsId) return { ...n, data: { ...data, variantStrategyId: vsId } };
        }
      }
      return n;
    }),
  };
}

/** v8 → v9: remove designer nodes (merged into hypothesis), rebuild hyp→variant edges */
function migrateV8ToV9(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];
  const designerIds = new Set(nodes.filter((n) => n.type === 'designer').map((n) => n.id as string));

  const newEdges: Array<Record<string, unknown>> = [];
  const hypothesisNodes = nodes.filter((n) => n.type === 'hypothesis');
  const variantNodes = nodes.filter((n) => n.type === 'variant');
  for (const hyp of hypothesisNodes) {
    const hypRefId = (hyp.data as Record<string, unknown> | undefined)?.refId as string | undefined;
    if (!hypRefId) continue;
    for (const v of variantNodes) {
      if ((v.data as Record<string, unknown> | undefined)?.variantStrategyId === hypRefId) {
        newEdges.push({ id: `e-${hyp.id as string}-${v.id as string}`, source: hyp.id as string, target: v.id as string, type: EDGE_TYPES.DATA_FLOW });
      }
    }
  }

  return {
    ...s,
    nodes: nodes.filter((n) => n.type !== 'designer'),
    edges: [
      ...edges.filter((e) => !designerIds.has(e.source as string) && !designerIds.has(e.target as string)),
      ...newEdges,
    ],
  };
}

/** v9 → v10: ensure hypothesis→variant edges exist */
function migrateV9ToV10(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];

  const existingKeys = new Set<string>();
  for (const e of edges) existingKeys.add(`${e.source as string}→${e.target as string}`);

  const newEdges: Array<Record<string, unknown>> = [];
  const hypothesisNodes = nodes.filter((n) => n.type === 'hypothesis');
  const variantNodes = nodes.filter((n) => n.type === 'variant');
  for (const hyp of hypothesisNodes) {
    const hypRefId = (hyp.data as Record<string, unknown> | undefined)?.refId as string | undefined;
    if (!hypRefId) continue;
    for (const v of variantNodes) {
      if ((v.data as Record<string, unknown> | undefined)?.variantStrategyId === hypRefId) {
        const key = `${hyp.id as string}→${v.id as string}`;
        if (!existingKeys.has(key)) {
          newEdges.push({ id: `e-${hyp.id as string}-${v.id as string}`, source: hyp.id as string, target: v.id as string, type: EDGE_TYPES.DATA_FLOW });
        }
      }
    }
  }

  return newEdges.length > 0 ? { ...s, edges: [...edges, ...newEdges] } : s;
}

/** Read design-system section data from the spec store in localStorage */
function readDesignSystemSection(storageKey: string): { content: string; images: unknown[] } {
  const specParsed = readLocalStorageJson(storageKey) as Record<string, unknown> | null;
  const spec = (specParsed?.state as Record<string, unknown> | undefined)?.spec as Record<string, unknown> | undefined;
  const dsData = (spec?.sections as Record<string, unknown> | undefined)?.['design-system'] as Record<string, unknown> | undefined;
  return {
    content: (dsData?.content as string | undefined) || '',
    images: (dsData?.images as unknown[] | undefined) || [],
  };
}

/** v10 → v11: designSystem is now self-contained (content in node.data, not spec store) */
function migrateV10ToV11(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];
  const { content: dsContent, images: dsImages } = readDesignSystemSection(STORAGE_KEYS.ACTIVE_CANVAS);

  const updatedNodes = nodes.map((n) => {
    if (n.type === 'designSystem') {
      const existingData = (n.data as Record<string, unknown>) || {};
      return { ...n, data: { ...existingData, title: 'Design System', content: dsContent, images: dsImages } };
    }
    return n;
  });

  const newEdges: Array<Record<string, unknown>> = [];
  const dsNodeIds = updatedNodes.filter((n) => n.type === 'designSystem').map((n) => n.id as string);
  const hypNodeIds = updatedNodes.filter((n) => n.type === 'hypothesis').map((n) => n.id as string);
  for (const dsId of dsNodeIds) {
    for (const hypId of hypNodeIds) {
      newEdges.push({ id: `edge-${dsId}-to-${hypId}`, source: dsId, target: hypId, type: EDGE_TYPES.DATA_FLOW });
    }
  }

  return { ...s, nodes: updatedNodes, edges: [...edges, ...newEdges] };
}

/** v11 → v12: re-attempt designSystem data recovery (v10→v11 may have run before spec hydration) */
function migrateV11ToV12(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];

  const hasMissingContent = nodes.some((n) => {
    if (n.type !== 'designSystem') return false;
    return !((n.data as Record<string, unknown>) || {}).content;
  });

  if (!hasMissingContent) return s;

  const { content: dsContent, images: dsImages } = readDesignSystemSection(STORAGE_KEYS.ACTIVE_CANVAS);
  if (!dsContent && dsImages.length === 0) return s;

  return {
    ...s,
    nodes: nodes.map((n) => {
      if (n.type !== 'designSystem') return n;
      const data = (n.data as Record<string, unknown>) || {};
      if (data.content) return n;
      return { ...n, data: { ...data, title: data.title || 'Design System', content: dsContent, images: dsImages } };
    }),
  };
}

/** v12 → v13: extract inline providerId/modelId into dedicated Model nodes */
function migrateV12ToV13(s: Record<string, unknown>): Record<string, unknown> {
  const nodes = (s.nodes as Array<Record<string, unknown>>) ?? [];
  const edges = (s.edges as Array<Record<string, unknown>>) ?? [];

  const PROCESSING_TYPES = new Set(['compiler', 'hypothesis', 'designSystem']);
  const nodesWithModel: Array<{ node: Record<string, unknown>; providerId: string; modelId: string }> = [];
  for (const n of nodes) {
    if (!PROCESSING_TYPES.has(n.type as string)) continue;
    const data = (n.data as Record<string, unknown>) || {};
    const pid = data.providerId as string | undefined;
    const mid = data.modelId as string | undefined;
    if (pid && mid) nodesWithModel.push({ node: n, providerId: pid, modelId: mid });
  }

  if (nodesWithModel.length === 0) return s;

  const combos = new Map<string, { providerId: string; modelId: string; targetIds: string[] }>();
  for (const { node, providerId, modelId } of nodesWithModel) {
    const key = `${providerId}::${modelId}`;
    if (!combos.has(key)) combos.set(key, { providerId, modelId, targetIds: [] });
    combos.get(key)!.targetIds.push(node.id as string);
  }

  const newModelNodes: Array<Record<string, unknown>> = [];
  const newEdges: Array<Record<string, unknown>> = [];

  let modelIdx = 0;
  for (const [, combo] of combos) {
    const modelNodeId = `model-migrated-${modelIdx++}`;
    const shortName = combo.modelId.split('/').pop() ?? combo.modelId;
    const label = `${combo.providerId} / ${shortName}`;

    const targetNodes = nodes.filter((n) => combo.targetIds.includes(n.id as string));
    const avgY = targetNodes.length > 0
      ? targetNodes.reduce((sum, n) => sum + ((n.position as Record<string, number>)?.y ?? 300), 0) / targetNodes.length
      : 300;
    const minX = targetNodes.length > 0
      ? Math.min(...targetNodes.map((n) => (n.position as Record<string, number>)?.x ?? 0))
      : 0;

    newModelNodes.push({
      id: modelNodeId,
      type: 'model',
      position: { x: Math.max(0, minX - 400), y: avgY },
      data: { title: label, providerId: combo.providerId, modelId: combo.modelId },
    });

    for (const tid of combo.targetIds) {
      newEdges.push({ id: `edge-${modelNodeId}-to-${tid}`, source: modelNodeId, target: tid, type: EDGE_TYPES.DATA_FLOW, data: { status: EDGE_STATUS.IDLE } });
    }
  }

  const updatedNodes = nodes.map((n) => {
    if (!PROCESSING_TYPES.has(n.type as string)) return n;
    const data = { ...((n.data as Record<string, unknown>) || {}) };
    delete data.providerId;
    delete data.modelId;
    return { ...n, data };
  });

  return { ...s, nodes: [...updatedNodes, ...newModelNodes], edges: [...edges, ...newEdges] };
}

// ── Top-level migration runner ────────────────────────────────────────

/**
 * Run all canvas store migrations from `fromVersion` → current.
 */
export function migrateCanvasState(
  state: unknown,
  fromVersion: number,
): Record<string, unknown> {
  // v0/v1 → v4: too old to migrate incrementally, reset
  if (fromVersion < 2) return { ...FRESH_STATE };

  let s = state as Record<string, unknown>;

  if (fromVersion < 3) s = migrateV2ToV3(s);

  // v3 → v4: reset canvas for multi-compiler/generator support
  if (fromVersion < 4) return { ...FRESH_STATE };

  if (fromVersion < 6) s = migrateV5ToV6(s);
  if (fromVersion < 7) s = migrateV6ToV7(s);
  // v7 → v8: provider/model/format now stored in node data (no transform needed)
  if (fromVersion < 9) s = migrateV8ToV9(s);
  if (fromVersion < 10) s = migrateV9ToV10(s);
  if (fromVersion < 11) s = migrateV10ToV11(s);
  if (fromVersion < 12) s = migrateV11ToV12(s);
  if (fromVersion < 13) s = migrateV12ToV13(s);

  return s;
}
